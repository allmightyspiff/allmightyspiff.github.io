<!DOCTYPE html>
<html>
  <head>
    <title>Day 14 - Databases</title>
    <meta charset="utf-8">
    <style>
      body { 
        font-family: monospace; 
        font-size: 2em;
      }
      h1 {
        font-family: monospace;
        color: #F2B632;
      } 
      h2 {
        font-family: monospace;
        color: #8834A5;
      }
      h3 {
        color: #A57712;
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Courier New'; }
      .remark-slide-content {
        background-color: #252839;
        color: #E1F4EC;
        font-size: 25px;
        padding: 0em 1em 1em 1em;
      }
    img {background-color: #E1F4EC ;}
    .columnA {float:left; width: 49%;}
    .columnB {float:right; width: 49%; }
    .columnD {float:right; width: 39%; }
    .columnC {float:left; width: 60%; }
    a {color:#A57712; }
    hr {border-color: #8834A5; background-color:#8834A5; border-width: 2px; border-style: solid; }
    li {margin-bottom: .5em; margin-top: .5em;}
    blockquote { 
        color: #F2B632;
        font-family: Palatino;
        font-weight: normal;
        font-size: 35px;
     }
     .MathJax {
     font-size: 8em !important;
     color: #D69ECA !important;
    }
    table {
        table-layout: fixed;
    }
    th {
      border-color: #8834A5;
      padding: 10px;
      border: solid;
    }
    td {
        border: solid;
        border-color: #8834A5;
        text-align: center;
    }
    .brightGold {
      color: #F2B632
    }
    .lightPurple {
      color: #8834A5 ;
    }
    .darkPurle {
        .color: #27182C;
    }
    .bigO {
      height: 475px;
    }
    .remark-code{
        font-size: 20px;
    }

    </style>
<!-- <link rel="stylesheet" href="/remark/default.min.css"> -->
  </head>
  <body>
    <!--#A57712  Dark Gold-->
    <!--#E1F4EC  White Gold -->
    <!--#F2B632  Bright Gold -->
    <!--#27182C  Dark Purple -->
    <!--#8834A5  Light Purple -->
    <!--#D69ECA  White Purple -->
    <textarea id="source">


class: center, middle
# .center[Data Structures]

---

# What is a Data Structure?
>In computer science, a data structure is a particular way of organizing data in a computer so that it can be used efficiently. Generally built upon simpler primitive data types:

--Donald Knuth, The Art of Computer Programming, vol. 1.

???
A general way of using a computer to organize data.

---

# Primitives
A variable can be
1. A primitive type. Int, char, boolean, float.
2. Another varible.
3. An Object

Primitves keep track of a single data point. Data Structures help keep track of multiple or complex data points.

---

# Array
An array is a collection of primitives.

- O(n) size, cannot be changed
- O(1) lookup speed

| 0x000 | 0x008 | 0x016 | 0x024 | 
| --- | --- | --- | --- |
| a[0] | a[1] | a[2]| a[3] |
| 't' | 'e' | 's' | 't' |

---

# A Basic Data Structure

```pyhthon
class point(x=0, y=0):
  def __init__(self, x=0, y=0):
    self.x = x
    self.y = 0
  def __eq__(self, b):
    return self.x == b.x && self.y == b.y

```

---

# Linked List
.columnA[
- Collection of nodes.
- Each node has a pointed to the next
- Easy to expand, insert, remove
- Takes O(n) time to get to an element
- O(2n) size, but can be easily added to.
]

.columnB[
- Ideal for
  - modifying members of the list, add / insert / remove
  - Iterating through the list in order
  - Can use multiple data types as elements
- Not Ideal for 
  + Randomly accessing members
  + Uses more memory than arrays
]

https://www.codefellows.org/blog/implementing-a-singly-linked-list-in-python/

---

# Linked List Code
```python
class Node():
    def __init__(self, data=None):
        self.data = data
        self.next = None
class linked_list():
    def __init__(self):
        self.head = None
        self.current = None
        self.tail = None
    def add_node(self, node):
        if self.head is None:
            self.head = node
            self.tail = node
        else:
            self.tail.next = node
            self.tail = node 
if __name__ == "__main__":
    my_list = linked_list()
    my_list.add_node(Node('a'))
    my_list.add_node(Node('b'))
    my_list.add_node(Node(100))
    print(my_list.head.next.data)
```
---

# Linked List variations
- doubly linked
  + Linked list with a pointer going backwards as well as forwards.
- queue
  + Linked lists that only add nodes at the tail, and remove from the head
- dequeue
  + a generalization of stacks and queues (the name is pronounced “deck” and is short for “double-ended queue”)
- stack
  + Linked list that only add and remove nodes from the tail

---

# Hash Tables
- Elements can be accessed in O(1) time
- Size varies, but usually O(n^2)
- Requires a hash function and a unique key to identify elements

| Id | Memory Location |
| --- | --- |
|0 |0x0001 |
|1 |0x0002 |
|2 |0x000A |
|3 |0x00FF |
|4 |0x0A01 |
|5 |null   |
|6 |null   |
|7 |null   |

---

# Hash Functions
```
hash(int(key) % len(hash_table))
```
- Easy to compute: It should be easy to compute and must not become an algorithm in itself.
- Uniform distribution: It should provide a uniform distribution across the hash table and should not result in clustering.
- Less collisions: Collisions occur when pairs of elements are mapped to the same hash value. These should be avoided. 
- An object is hashable if it has a hash value which never changes during its lifetime (it needs a __hash__() method), and can be compared to other objects (it needs an __eq__() method). Hashable objects which compare equal must have the same hash value.

---
# Hash Collisions
https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial/
- Separate Chaining (open hashing)
- Probing (closed hashing)
- Growing the Hash Table

---

# Distributed and Consistent Hashing
http://theory.stanford.edu/~tim/s17/l/l1.pdf
- The goal of consistent hashing: we want hash table-type functionality with the additional property that almost all objects stay assigned to the same cache even as the number n of caches changes.
- Give locations effectively random numbers between 0 and infinity.
- Don’t compute hash % number of locations. Instead, find the smallest location number greater than your key’s hash, and put it there.
- If your hash is greater than all locations, put it in the lowest-numbered location.
- I start with five locations randomly numbered 1, 20, 41, 1024, 2016. Given a key with hash 1013, I put it in the location numbered 1024. Given a key with hash 2017, I put it in the location numbered 1.
---



# Trees
- Root and Parent
- Child and Siblings
- Branches
- Leaves / Nodes
- Height
---

# Tree Uses
- Representing hierarchical data
- Storing data in a way that makes it efficiently searchable (see binary search tree and tree traversal)
- Storing node relationships
- As a workflow for compositing digital images for visual effects
- Routing algorithms

???
### Routing
When applying link-state algorithms, a graphical map of the network is the fundamental data used for each node. To produce its map, each node floods the entire network with information about the other nodes it can connect to. Each node then independently assembles this information into a map. Using this map, each router independently determines the least-cost path from itself to every other node using a standard shortest paths algorithm such as Dijkstra's algorithm. The result is a tree graph rooted at the current node, such that the path through the tree from the root to any other node is the least-cost path to that node. This tree then serves to construct the routing table, which specifies the best next hop to get from the current node to any other node.

---

# Binary Trees
https://en.wikipedia.org/wiki/Binary_tree
http://cslibrary.stanford.edu/110/BinaryTrees.html
https://en.wikipedia.org/wiki/Tree_traversal

each node only has a left and right node
- Depth First
- Breadth First
- Height / Depth

---

# Red Black Tree
http://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/
.columnA[
1. Every node has a color either red or black.
2. Root of tree is always black.
3. There are no two adjacent red nodes (A red node cannot have a red parent or red child).
4. Every path from root to a NULL node has same number of black nodes.
]
.columnB[
<img width=500px src='/CS/Day8/redBlack.png'>
]

---


# Binary Heap
.columnA[
A binary heap is defined as a binary tree with two additional constraints:

*Shape property*: a binary heap is a complete binary tree; that is, all levels of the tree, except possibly the last one (deepest) are fully filled, and, if the last level of the tree is not complete, the nodes of that level are filled from left to right.

*Heap property*: the key stored in each node is either greater than or equal to (≥) or less than or equal to (≤) the keys in the node's children, according to some total order.
]
.columnB[
<img src='/CS/Day8/heap.png'>
]

---

</textarea>
    <script src="/remark/remark-latest.min.js"></script>
    <script src="/remark/jquery-2.2.4.min.js"></script>
    <script src="/remark/highlight.min.js"></script>
    <script type="text/javascript">
      var slideshow = remark.create({
        highlightStyle: 'default',
        ratio: '16:9',
        highlightLines: true
      });
      var hljs = hljs1.initHighlightingOnLoad();
    </script>
  </body>
</html>